<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <!-- 연습문제 p.102(7번 제외) -->
<!-- <script>
    const arr = [100,200,300,400,500,600,700];
    // 1. for-in문을 사용하여 배열의 인덱스(키)를 출력
    for (var prop in arr){
        console.log(prop);
    }
    // 2. for-in문을 사용하여 배열의 원소(값)를 출력 (of)
    for (var value in arr){
        console.log(arr[value]);
    }
    for (var value of arr){
        console.log(value);
    }

    const obj = {name:'Kim', addr:'Yongsan', level:1, role:9, receive:false};
    // 3. for-in 프로퍼티 이름(키) 출력
    for (var key in obj){
        console.log(key);
    }
    // 4. for-in 프로퍼티 값 출력
    for (var key in obj){
        console.log(obj[key]);
    }
    // 5. for-of 프로퍼티 값 출력
    for (const val of Object.values(obj)){
        console.log(val);
    }
    // 6. level 프로퍼티가 열거(entries)되지 않도록 설정 // Object.defineProperty
    console.log(obj.ppropertyIsEnumerable("level")); // true 출력
    Object.defineProperty(obj,'level',  {
        enumerable:false
    });
    console.log(obj.ppropertyIsEnumerable("level")); // false 출력
    console.log(obj.level);

    // 7. role 프로퍼티티 읽기전용 설정 // Object.defineProperty
</script> -->

    <!-- 연습문제 p.103 -->

<!-- <script>
    data = [
        ['A',10,20],
        ['B',30,40],
        ['C',50,60,70]
    ]; // 배열을 객체로 만드시오
    //makeObjectFromArray => {'A':[10,20]], 'B':[30,40], 'C':[50,60,70]}
    function makeObjectFromArray(arr){
        const obj = {};
        for (let arr of data) {
            const [key, ...values] = arr;
            obj[key] = values;
        }
        return obj;
    }
    dataObject = makeObjectFromArray(data);
    console.log(dataObject);

    //위에서 만든 객체를 다시 배열로 반드시오 (makeArrayFromObject)

    function makeArrayFromObject(obj){
        const result = [];
        for (let key in obj){
            result.push([key, ...obj[key]]);
        }
        return result;
    }
    dataArray = makeArrayFromObject(dataObject);
    console.log(dataArray);
</script> -->

    <!-- 연습문제 p.104 -->

<script>
    // 원시값만을 갖는 객체 kim을 복사하는 프로그램을
    // Object의 클래스 메소드 또는 spread(...)연산자 사용하지 말고 작성
    // 1) shallow copy
    const kim = {nid:3, nm:'Kim', addr: 'Pusan'};

    function shallowCopy(obj){
        const newObj = {};
        for (let key in obj){
            if (obj.hasOwnProperty(key)){
                newObj[key] = obj[key];
            }
        }
        return newObj;
    }
    // function shallowCopy(obj){ // 내부적으로 deep copy 수행됨
    //     let newObj = JSON.stringify(obj);
    //     newObj = JSON.parse(newObj);
    //     return newObj;
    // }
    const newKim1 = shallowCopy(kim);
    newKim1.addr = 'Daegu';
    console.log(kim.addr !== newKim1.addr); //true면 통과
    console.log(kim);
    console.log(newKim1);

    //2) 이하 deep copy
    const kim2 = {
        nid:3,
        nm:'Kim',
        addr:{city:'Pusan',road:'Haeundaero',zip:null}
    };

    // function deepCopy(obj){
    //     const newObj = {};
    //     for (let key in obj){
    //         if (obj.hasOwnProperty(key)){
    //             const value = obj[key];
    //             if (typeof value === 'object' && value !== null){
    //                 newObj[key] = deepCopy(value);
    //             } else {
    //                 newObj[key] = value;
    //             }
    //         }
    //     }
    //     return newObj;
    // }
    function deepCopy(obj) {
        let newObj = JSON.stringify(obj);
        newObj = JSON.parse(newObj);
        return newObj;
    }
    const newKim2 = deepCopy(kim2);
    newKim2.addr.city = 'Daegu';
    console.log(kim2.addr.city !== newKim2.addr.city); //true면 통과
    console.log(kim2);
    console.log(newKim2);
</script>
</body>
</html>