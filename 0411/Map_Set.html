<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <!-- <script>
        const map = new Map();
        console.log(map); //Map(0) {}

        const map1 = new Map(([['key1','value1'],['key2','value2']]));
        console.log(map1); //Map(2) {'key1' => 'value1', 'key2' => 'value2'}

        // const map2 = new Map([1,2]); //TypeError:Iterator value 1 is not an entry object
        const map3 = new Map([[1,2],[3,4]]);
        console.log(map3);
    </script> -->


    <!-- <script>
        const {size} = new Map(([['key1', 'value1'], ['key2', 'value2']]));
        console.log(size);

        const map = new Map(([['key1', 'value1'], ['key2', 'value2']]));
        console.log(Object.getOwnPropertyDescriptor(Map.prototype, 'size'));
        // {
        //     get: [Function: get size],
        //     set: undefined,
        //     enumerable: false,
        //     configurable: true
        // }
        map.size = 10;
        console.log(map.size); //2
    </script> -->


    <!-- <script>
        const memberList = new Map();
        memberList.set(20, "conan");
        memberList.set(50, "rose");
        memberList.set(120, "ran");

        console.log(memberList);
        
        //method chaining
        memberList.set(20,"conan").set(50,"rose").set(120,"ran");
        console.log(memberList);

        console.log(memberList.get(20)); //conan
        console.log(memberList.has(50)); //true

        const memeberList = new Map();
        memberList.set(20, "conan");
        memberList.set(20, "rose"); // 중복키를 갖는 요소 존재할 수 없으므로 20->rose저장
        console.log(memberList.get(20));

        const map = new Map();
        const keySymbol = Symbol();
        map.set(keySymbol, 'conan');
        console.log(map.get(keySymbol)); //conan

        const map2 = new Map();
        const conan = {name:"코난"};
        const rose = {name:"장미"};
        map2.set(conan, 'detective').set(rose, 'chemist');
        console.log(map2);
    </script> -->


    <!-- <script>
        const conan = {name:"코난"};
        const rose = {name:"장미"};
        const map
        = new Map([[conan, 'developer'], [rose, 'designer']]);
        console.log(map.has(conan));
        console.log(map.has('key'));

        console.log(map);
        map.delete(conan);
        console.log(map);

        //존재하지 않는 키로 삭제하는 경우 에러 없이 무시
        //method chaining 할 수 없음
        // map.delete(conan).delet(rose); //TypeError:map.delete(...)delete is not a function

        map.clear(); // 일괄삭제
        console.log(map);
    </script> -->


    <!-- <script>
        const map = new Map(([['key1', 'value1'], ['key2', 'value2']]));
        const keyList = map.keys();
        for (let key of keyList) {
            console.log(key); //key1 key2
        }
        const valueList = map.values();
        for (let value of valueList) {
            console.log(value); // value1 value2
        }
        const entryList = map.entries();
        for (let entry of entryList) {
            console.log(entry); // ['key1', 'value1'] ['key2', 'value2']
        }
        map.forEach((value, key) => {
            console.log(`${key}:${value}`);
        }) // key1: value1 key2: value2
    </script> -->


    <!-- <script>
        // 중복되지 않은 유일한 값들의 집합합
        const set = new Set();
        console.log(set); //Set(0) {}

        const set1 = new Set([1,2,3,3]); // 중복된 3 하나만 저장
        console.log(set1); //Set(3) {1,2,3}

        const set2 = new Set('hello'); // 중복된 "l" 하나만 저장
        console.log(set2); //set(4) {"h","e","l","o"}

        const {size} = new Set([1,2,3,3]); // size 프로퍼티 사용
        console.log(size); //3
    </script> -->


    <!-- <script>
        const set = new Set();

        set.add(1).add(2).add(2);
        console.log(set); //Set(2) {1,2}

        //Nan, 0/-0 <- Map의 키에도 적용
        const set2 = new Set();

        console.log(NaN === NaN); //false
        console.log(0 === -0); //true

        //NaN과 NaN을 같다고 평가
        set2.add(NaN).add(NaN);
        console.log(set2); //Set(1) {NaN}

        //+0과 -0을 같다고 평가
        set2.add(0).add(-0);
        console.log(set2); //Set(2) {NaN,0}
    </script> -->


    <!-- <script>
        //배열의 중복 요소 제거
        const uniq = array => array.filter((v,i,self) => self.indexOf(v) === i);
        console.log(uniq([2,1,2,3,4,3,4])); // [2,1,3,4]

        //Set을 사용한 배열의 중복 요소 제거
        const uniq2 = array => [...new Set(array)];
        console.log(uniq2([2,1,2,3,4,3,4,])); //[2,1,3,4]
    </script> -->


    <script>
        const set = new Set([1,2,3]);
        set.forEach((v,v2,set) => console.log(v,v2,set));

        //Set.prototype의 Symbol.iterator 메서드를 상속받는 이터러블
        console.log(Symbol.iterator in set); //true

        //이터러블이므로 for...of문 사용 가능
        for (const value of set) {
            console.log(value); //123
        }
        
        //이터러블이므로 스프레드 문법 사용 가능
        console.log([...set]); //[1,2,3]

        //이터러블이므로 배열 디스트럭처링 할당 사용 가능
        const [a, ...rest] = [...set];
        console.log(a, rest); //1, [2,3]
    </script>
</body>
</html>